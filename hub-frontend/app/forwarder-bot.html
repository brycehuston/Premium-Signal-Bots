<!-- magnetic_router_split_TOPDOWN_CLEAN_v3.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Magnetic Router Split (Top-Down Clean v3)</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #05070c;
            overflow: hidden;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
            color: #fff;
        }

        .wrap {
            height: 100%;
            display: grid;
            place-items: center;
            padding: 18px;
        }

        .card {
            width: min(980px, 96vw);
            height: min(600px, 86vh);
            border-radius: 22px;
            position: relative;
            overflow: hidden;
            background:
                radial-gradient(900px 700px at 50% 30%, rgba(140, 230, 255, 0.10), transparent 60%),
                radial-gradient(900px 700px at 18% 78%, rgba(255, 210, 140, 0.06), transparent 55%),
                linear-gradient(to bottom right, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 30px 90px rgba(0, 0, 0, 0.65);
        }

        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="card" id="card">
            <canvas id="cv"></canvas>
        </div>
    </div>

    <script>
        (() => {
            const card = document.getElementById("card");
            const canvas = document.getElementById("cv");
            const ctx = canvas.getContext("2d", { alpha: true });

            // ============================================================
            // CONFIG
            // ============================================================
            const CFG = {
                dprMax: 2,

                // Background
                stars: 120,
                vignette: 0.84,

                // Colors
                cyan: [120, 220, 255],
                blue: [70, 160, 255],

                // Lane colors (Bronze / Silver / Gold)
                early: [199, 142, 84],
                trend: [215, 224, 238],
                runner: [255, 205, 110],

                // Layout
                sourceX: 0.50,
                sourceY: 0.12,
                ringX: 0.50,
                ringY: 0.48,
                outY: 0.88,
                laneOffsetX: 0.24,

                // Timing
                inDurMs: 1400,
                orbitMs: 1200,
                outDurMs: 2500,
                orbitLoops: 1,

                // Ring size
                ringRadiusFactor: 0.075,

                // Packet visuals
                packetSize: 2.6,
                packetGlow: 18,

                // Trail ONLY while routing out
                tailSteps: 10,
                tailCutoffT: 0.92,

                // Split flash
                splitFlashMs: 320,
                splitBeamAlpha: 0.26,

                // Pulses
                lanePulseMs: 900,
                pillFlashMs: 800,

                // Hold exit
                exitHoldMs: 260,

                // ✅ Click pulse (Telegram)
                clickPulseMs: 650,
                // ✅ about 1/4 the previous scale (0.38 -> ~0.095)
                clickPulseScale: 0.095,

                // Traffic
                randomSpawn: {
                    pauseChance: 0.14,
                    pauseMinMs: 9000,
                    pauseMaxMs: 12000,

                    singleChance: 0.50,
                    burst2Chance: 0.26,
                    burst3Chance: 0.10,

                    singleFastChance: 0.35,
                    singleFastMinMs: 120,
                    singleFastMaxMs: 900,

                    singleSlowMinMs: 2500,
                    singleSlowMaxMs: 5200,

                    burstMinMs: 700,
                    burstMaxMs: 2200,

                    burstSpacingMs: 90
                }
            };

            // ============================================================
            // Helpers
            // ============================================================
            const TAU = Math.PI * 2;
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const lerp = (a, b, t) => a + (b - a) * t;
            const rgba = (rgb, a) => `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
            const rand = (a, b) => a + Math.random() * (b - a);

            function easeInOutSine(t) {
                return -(Math.cos(Math.PI * t) - 1) / 2;
            }
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            function bezierPoint(p0, p1, p2, p3, t) {
                const u = 1 - t;
                const tt = t * t;
                const uu = u * u;
                const uuu = uu * u;
                const ttt = tt * t;

                return {
                    x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
                    y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
                };
            }

            function roundRect(ctx, x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx.beginPath();
                ctx.moveTo(x + rr, y);
                ctx.arcTo(x + w, y, x + w, y + h, rr);
                ctx.arcTo(x + w, y + h, x, y + h, rr);
                ctx.arcTo(x, y + h, x, y, rr);
                ctx.arcTo(x, y, x + w, y, rr);
                ctx.closePath();
            }

            // ============================================================
            // DPI / Resize
            // ============================================================
            let W = 0, H = 0, DPR = 1;

            function resize() {
                DPR = Math.max(1, Math.min(CFG.dprMax, window.devicePixelRatio || 1));
                const r = card.getBoundingClientRect();
                W = Math.max(1, Math.floor(r.width));
                H = Math.max(1, Math.floor(r.height));

                canvas.width = Math.floor(W * DPR);
                canvas.height = Math.floor(H * DPR);
                canvas.style.width = W + "px";
                canvas.style.height = H + "px";
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

                initStars();
            }
            window.addEventListener("resize", resize);

            // ============================================================
            // Keyboard lane lock
            // ============================================================
            let laneLock = null; // null=auto, 0/1/2 locked
            window.addEventListener("keydown", (e) => {
                if (e.key === "0") laneLock = null;
                if (e.key === "1") laneLock = 0;
                if (e.key === "2") laneLock = 1;
                if (e.key === "3") laneLock = 2;
            });

            function laneColor(laneId) {
                if (laneId === 0) return CFG.early;
                if (laneId === 1) return CFG.trend;
                return CFG.runner;
            }

            // ============================================================
            // Stars BG
            // ============================================================
            const stars = [];
            function initStars() {
                stars.length = 0;
                for (let i = 0; i < CFG.stars; i++) {
                    stars.push({
                        x: Math.random() * W,
                        y: Math.random() * H,
                        r: 0.6 + Math.random() * 1.1,
                        a: 0.03 + Math.random() * 0.10
                    });
                }
            }

            function drawStars() {
                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                for (const s of stars) {
                    ctx.fillStyle = `rgba(255,255,255,${s.a})`;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, TAU);
                    ctx.fill();
                }
                ctx.restore();
            }

            // ============================================================
            // Visual primitives
            // ============================================================
            function drawGlowDot(x, y, rgb, alpha, size, glow) {
                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                const g = ctx.createRadialGradient(x, y, 0, x, y, glow);
                g.addColorStop(0.0, rgba(rgb, alpha));
                g.addColorStop(0.45, rgba(rgb, alpha * 0.22));
                g.addColorStop(1.0, "rgba(0,0,0,0)");

                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, TAU);
                ctx.fill();

                ctx.fillStyle = `rgba(255,255,255,${alpha * 0.14})`;
                ctx.beginPath();
                ctx.arc(x - size * 0.35, y - size * 0.35, size * 0.42, 0, TAU);
                ctx.fill();

                ctx.restore();
            }

            // ✅ Orb now supports scale + clickPulse ring
            function drawOrb(cx, cy, r, now, rgbMain, scale = 1, clickPulseAmt = 0) {
                const pulse = (Math.sin(now * 0.0018) + 1) * 0.5;
                const rr = r * scale;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                // outer bloom
                const gOuter = ctx.createRadialGradient(cx, cy, rr * 0.2, cx, cy, rr * (2.6 + pulse * 0.25));
                gOuter.addColorStop(0.0, rgba(rgbMain, 0.18));
                gOuter.addColorStop(0.45, "rgba(70,160,255,0.07)");
                gOuter.addColorStop(1.0, "rgba(0,0,0,0)");
                ctx.fillStyle = gOuter;
                ctx.beginPath();
                ctx.arc(cx, cy, rr * (2.6 + pulse * 0.25), 0, TAU);
                ctx.fill();

                // glass
                const glass = ctx.createRadialGradient(cx - rr * 0.35, cy - rr * 0.35, 0, cx, cy, rr * 1.25);
                glass.addColorStop(0.0, "rgba(255,255,255,0.18)");
                glass.addColorStop(0.25, rgba(rgbMain, 0.10));
                glass.addColorStop(0.62, "rgba(10,16,26,0.14)");
                glass.addColorStop(1.0, "rgba(0,0,0,0)");
                ctx.fillStyle = glass;
                ctx.beginPath();
                ctx.arc(cx, cy, rr * 1.02, 0, TAU);
                ctx.fill();

                // outline
                ctx.strokeStyle = rgba(rgbMain, 0.45);
                ctx.lineWidth = 1.6;
                ctx.beginPath();
                ctx.arc(cx, cy, rr * 1.02, 0, TAU);
                ctx.stroke();

                // ✅ click pulse ripple (starts 0 -> expands -> back to 0)
                if (clickPulseAmt > 0.001) {
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";

                    const rippleR = rr * (1.05 + 1.05 * clickPulseAmt);
                    const rippleA = 0.16 * clickPulseAmt;

                    ctx.strokeStyle = rgba(rgbMain, rippleA);
                    ctx.lineWidth = 2.0;
                    ctx.beginPath();
                    ctx.arc(cx, cy, rippleR, 0, TAU);
                    ctx.stroke();

                    const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rippleR * 1.25);
                    g.addColorStop(0.0, rgba(rgbMain, 0.10 * clickPulseAmt));
                    g.addColorStop(0.45, rgba(rgbMain, 0.05 * clickPulseAmt));
                    g.addColorStop(1.0, "rgba(0,0,0,0)");
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(cx, cy, rippleR * 1.25, 0, TAU);
                    ctx.fill();

                    ctx.restore();
                }

                ctx.restore();
            }

            function drawNodeLabel(x, y, text, rgb, alpha = 1, big = false) {
                const padX = big ? 18 : 14;
                const h = big ? 34 : 30;

                ctx.save();
                ctx.globalCompositeOperation = "source-over";
                ctx.font = big
                    ? "900 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial"
                    : "900 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
                const w = ctx.measureText(text).width + padX * 2;

                ctx.fillStyle = `rgba(0,0,0,${0.36 * alpha})`;
                ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${0.32 * alpha})`;
                ctx.lineWidth = 1;

                roundRect(ctx, x - w / 2, y - h / 2, w, h, 999);
                ctx.fill();
                ctx.stroke();

                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                ctx.fillStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${0.06 * alpha})`;
                roundRect(ctx, x - w / 2 + 1, y - h / 2 + 1, w - 2, h - 2, 999);
                ctx.fill();
                ctx.restore();

                ctx.fillStyle = `rgba(255,255,255,${0.92 * alpha})`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, x, y + 0.5);

                ctx.restore();
            }

            // ✅ Less height + less rounded corners
            function drawPill(x, y, text, rgb, flashAmt) {
                const padX = 22;
                const h = 42;   // ✅ was 56 (shorter)
                const rad = 14; // ✅ was 999 (less rounded)

                ctx.save();
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "1000 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
                const w = ctx.measureText(text).width + padX * 2;

                // base
                ctx.fillStyle = "rgba(0,0,0,0.34)";
                ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.34)`;
                ctx.lineWidth = 1.25;
                roundRect(ctx, x - w / 2, y - h / 2, w, h, rad);
                ctx.fill();
                ctx.stroke();

                // inner tint
                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                ctx.fillStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.06)`;
                roundRect(ctx, x - w / 2 + 1, y - h / 2 + 1, w - 2, h - 2, rad - 1);
                ctx.fill();
                ctx.restore();

                // arrival pulse glow
                if (flashAmt > 0.01) {
                    ctx.save();
                    ctx.globalCompositeOperation = "lighter";

                    const glow = ctx.createRadialGradient(x, y, 0, x, y, 80);
                    glow.addColorStop(0.0, rgba(rgb, 0.20 * flashAmt));
                    glow.addColorStop(0.45, rgba(rgb, 0.10 * flashAmt));
                    glow.addColorStop(1.0, "rgba(0,0,0,0)");
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(x, y, 80, 0, TAU);
                    ctx.fill();

                    ctx.strokeStyle = rgba(rgb, 0.30 * flashAmt);
                    ctx.lineWidth = 2.2;
                    roundRect(ctx, x - w / 2, y - h / 2, w, h, rad);
                    ctx.stroke();

                    ctx.restore();
                }

                // text
                ctx.fillStyle = `rgba(255,255,255,${0.94 + flashAmt * 0.06})`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, x, y + 0.5);

                ctx.restore();
            }

            function drawMagneticRing(cx, cy, r, now, routeHint, hintA) {
                const t = now * 0.001;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 3.0);
                g.addColorStop(0.0, "rgba(255,255,255,0.04)");
                g.addColorStop(0.45, "rgba(120,220,255,0.08)");
                g.addColorStop(1.0, "rgba(0,0,0,0)");
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(cx, cy, r * 3.0, 0, TAU);
                ctx.fill();

                ctx.strokeStyle = "rgba(255,255,255,0.20)";
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, TAU);
                ctx.stroke();

                ctx.strokeStyle = "rgba(255,255,255,0.08)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(cx, cy, r * 0.72, 0, TAU);
                ctx.stroke();

                ctx.strokeStyle = "rgba(255,255,255,0.08)";
                ctx.lineWidth = 1.6;
                ctx.beginPath();
                ctx.arc(cx, cy, r, t, t + 0.75);
                ctx.stroke();

                if (routeHint >= 0 && hintA > 0.01) {
                    const rgb = laneColor(routeHint);
                    ctx.strokeStyle = rgba(rgb, 0.30 * hintA);
                    ctx.lineWidth = 2.6;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, -0.35, 0.35);
                    ctx.stroke();
                }

                ctx.restore();
            }

            function drawLaneCurve(p0, p1, p2, p3, rgb, boost) {
                ctx.save();
                ctx.globalCompositeOperation = "lighter";

                ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${0.10 + boost * 0.10})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([7, 12]);
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${0.05 + boost * 0.06})`;
                ctx.lineWidth = 5 + boost * 5;
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                ctx.stroke();

                ctx.restore();
            }

            function drawSplitBeams(curves, chosenLaneId, flashT) {
                const baseA = CFG.splitBeamAlpha * flashT;

                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                ctx.lineWidth = 2.2;

                for (const c of curves) {
                    const rgb = laneColor(c.laneId);
                    const isChosen = c.laneId === chosenLaneId;
                    const a = isChosen ? baseA * 1.25 : baseA * 0.55;

                    const grad = ctx.createLinearGradient(c.p0.x, c.p0.y, c.p3.x, c.p3.y);
                    grad.addColorStop(0.0, "rgba(255,255,255,0)");
                    grad.addColorStop(0.25, rgba(rgb, a * 0.55));
                    grad.addColorStop(0.55, rgba(rgb, a));
                    grad.addColorStop(1.0, "rgba(0,0,0,0)");

                    ctx.strokeStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(c.p0.x, c.p0.y);
                    ctx.bezierCurveTo(c.p1.x, c.p1.y, c.p2.x, c.p2.y, c.p3.x, c.p3.y);
                    ctx.stroke();
                }

                ctx.restore();
            }

            // ============================================================
            // Layout + Curves
            // ============================================================
            function getLayout() {
                const sx = W * CFG.sourceX;
                const sy = H * CFG.sourceY;

                const rx = W * CFG.ringX;
                const ry = H * CFG.ringY;

                const outY = H * CFG.outY;

                const laneX0 = W * (CFG.ringX - CFG.laneOffsetX);
                const laneX1 = W * (CFG.ringX);
                const laneX2 = W * (CFG.ringX + CFG.laneOffsetX);

                return {
                    sx, sy, rx, ry, outY,
                    lanes: [
                        { id: 0, x: laneX0, label: "EARLY" },
                        { id: 1, x: laneX1, label: "TREND" },
                        { id: 2, x: laneX2, label: "RUNNER" }
                    ]
                };
            }

            function buildCurves(L, ringR) {
                const p0 = { x: L.rx, y: L.ry + ringR * 1.02 };
                return L.lanes.map((lane) => {
                    const p3 = { x: lane.x, y: L.outY };
                    const bend = lane.x - L.rx;

                    const p1 = { x: p0.x + bend * 0.20, y: lerp(p0.y, p3.y, 0.35) };
                    const p2 = { x: p3.x - bend * 0.10, y: lerp(p0.y, p3.y, 0.65) };

                    return { laneId: lane.id, p0, p1, p2, p3 };
                });
            }

            // ============================================================
            // Packet system
            // ============================================================
            const packets = [];
            let rrIndex = 0;

            const lanePulseAt = [0, 0, 0];
            const pillFlashAt = [0, 0, 0];

            let splitFlashUntil = 0;
            let lastChosenLane = 1;

            let firstTrendDone = false;
            let allowRandomSpawns = false;

            // ✅ Telegram click pulse time
            let telegramClickAt = -999999;

            function chooseLane() {
                if (laneLock === null) {
                    const lane = rrIndex % 3;
                    rrIndex++;
                    return lane;
                }
                return laneLock;
            }

            function spawnPacket(now, laneOverride = null, isBoot = false) {
                const laneId = (laneOverride !== null) ? laneOverride : chooseLane();
                lastChosenLane = laneId;

                packets.push({
                    state: "in",
                    born: now,
                    laneId,
                    orbitStart: 0,
                    holdStart: 0,
                    outStart: 0,
                    isBoot
                });

                while (packets.length > 10) packets.shift();
            }

            // Random spawner
            let nextSpawnAt = performance.now() + rand(1400, 2600);

            function getRandomSpawnPlan() {
                const R = CFG.randomSpawn;
                const r = Math.random();

                if (r < R.pauseChance) return { count: 0, delayMs: rand(R.pauseMinMs, R.pauseMaxMs) };
                if (r < R.pauseChance + R.singleChance) {
                    const fast = Math.random() < R.singleFastChance;
                    const delayMs = fast ? rand(R.singleFastMinMs, R.singleFastMaxMs) : rand(R.singleSlowMinMs, R.singleSlowMaxMs);
                    return { count: 1, delayMs };
                }
                if (r < R.pauseChance + R.singleChance + R.burst2Chance) {
                    return { count: 2, delayMs: rand(R.burstMinMs, R.burstMaxMs) };
                }
                return { count: 3, delayMs: rand(R.burstMinMs, R.burstMaxMs) };
            }

            function handleSpawning(now) {
                if (!allowRandomSpawns) return;
                if (now < nextSpawnAt) return;

                const plan = getRandomSpawnPlan();
                if (plan.count > 0) {
                    for (let i = 0; i < plan.count; i++) {
                        spawnPacket(now + i * CFG.randomSpawn.burstSpacingMs);
                    }
                }
                nextSpawnAt = now + plan.delayMs;
            }

            // ============================================================
            // Click handler (Telegram bot pulse)
            // ============================================================
            function getPointerPos(e) {
                const r = card.getBoundingClientRect();
                const x = (e.clientX - r.left) * (W / r.width);
                const y = (e.clientY - r.top) * (H / r.height);
                return { x, y };
            }

            canvas.addEventListener("pointerdown", (e) => {
                const now = performance.now();
                const L = getLayout();
                const sourceR = Math.min(W, H) * 0.050;

                const p = getPointerPos(e);
                const dx = p.x - L.sx;
                const dy = p.y - L.sy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // ✅ only pulse when you click the telegram orb area
                if (dist <= sourceR * 1.35) {
                    telegramClickAt = now;
                }
            });

            // ============================================================
            // Main render loop
            // ============================================================
            function draw(now) {
                ctx.clearRect(0, 0, W, H);

                drawStars();

                // soft wash
                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                const bg = ctx.createRadialGradient(W * 0.50, H * 0.38, 0, W * 0.50, H * 0.38, Math.min(W, H) * 0.90);
                bg.addColorStop(0.0, "rgba(120,220,255,0.03)");
                bg.addColorStop(0.5, "rgba(70,160,255,0.02)");
                bg.addColorStop(1.0, "rgba(0,0,0,0)");
                ctx.fillStyle = bg;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();

                const L = getLayout();
                const ringR = Math.min(W, H) * CFG.ringRadiusFactor;
                const curves = buildCurves(L, ringR);

                // lane pulse strength
                const laneBoost = [0, 0, 0];
                for (let i = 0; i < 3; i++) {
                    const age = now - lanePulseAt[i];
                    const t = clamp(1 - age / CFG.lanePulseMs, 0, 1);
                    laneBoost[i] = easeOutCubic(t);
                }

                // draw lanes
                for (const c of curves) {
                    drawLaneCurve(c.p0, c.p1, c.p2, c.p3, laneColor(c.laneId), laneBoost[c.laneId]);
                }

                // ✅ FIXED CLICK PULSE:
                // Instead of starting huge and shrinking:
                // we do a smooth wave: 0 -> 1 -> 0
                const clickAge = now - telegramClickAt;
                const clickNorm = clamp(clickAge / CFG.clickPulseMs, 0, 1);
                const clickWave = Math.sin(Math.PI * clickNorm); // 0..1..0
                const clickAmt = easeOutCubic(clickWave);        // smoother feel

                const telegramScale = 1 + (CFG.clickPulseScale * clickAmt);

                // Telegram node
                const sourceR = Math.min(W, H) * 0.050;
                drawOrb(L.sx, L.sy, sourceR, now, CFG.blue, telegramScale, clickAmt);
                drawNodeLabel(L.sx, L.sy - (sourceR * telegramScale + 28), "TELEGRAM BOT", CFG.blue, 0.95, true);

                // input line (telegram -> ring)
                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                ctx.strokeStyle = "rgba(120,220,255,0.10)";
                ctx.lineWidth = 2;
                ctx.setLineDash([7, 12]);
                ctx.beginPath();
                ctx.moveTo(L.sx, L.sy + sourceR * 1.2);
                ctx.lineTo(L.rx, L.ry - ringR * 1.25);
                ctx.stroke();
                ctx.restore();

                // pill pulse strength (arrival)
                const pillFlashAmt = [0, 0, 0];
                for (let i = 0; i < 3; i++) {
                    const age = now - pillFlashAt[i];
                    const t = clamp(1 - age / CFG.pillFlashMs, 0, 1);
                    pillFlashAmt[i] = easeOutCubic(t);
                }

                // destination pills
                drawPill(L.lanes[0].x, L.outY, "EARLY", CFG.early, pillFlashAmt[0]);
                drawPill(L.lanes[1].x, L.outY, "TREND", CFG.trend, pillFlashAmt[1]);
                drawPill(L.lanes[2].x, L.outY, "RUNNER", CFG.runner, pillFlashAmt[2]);

                // spawning
                handleSpawning(now);

                // split beams flash
                if (now < splitFlashUntil) {
                    let flashT = clamp((splitFlashUntil - now) / CFG.splitFlashMs, 0, 1);
                    flashT = easeOutCubic(flashT);
                    drawSplitBeams(curves, lastChosenLane, flashT);
                }

                let routeHint = -1;
                let hintA = 0;

                // packets
                for (let i = packets.length - 1; i >= 0; i--) {
                    const p = packets[i];

                    // IN: telegram -> ring
                    if (p.state === "in") {
                        const t = clamp((now - p.born) / CFG.inDurMs, 0, 1);
                        const e = easeInOutSine(t);

                        const x0 = L.sx;
                        const y0 = L.sy + sourceR * 1.05;

                        const x1 = L.rx;
                        const y1 = L.ry - ringR * 1.05;

                        const x = lerp(x0, x1, e);
                        const y = lerp(y0, y1, e);

                        drawGlowDot(x, y, CFG.cyan, 0.90, CFG.packetSize, CFG.packetGlow);

                        if (t >= 1) {
                            p.state = "orbit";
                            p.orbitStart = now;
                        }
                    }

                    // ORBIT around ring
                    else if (p.state === "orbit") {
                        const t = clamp((now - p.orbitStart) / CFG.orbitMs, 0, 1);
                        const e = easeInOutSine(t);

                        const cx = L.rx;
                        const cy = L.ry;

                        const startAng = -Math.PI / 2;
                        const endAng = (Math.PI / 2) + CFG.orbitLoops * TAU;
                        const ang = lerp(startAng, endAng, e);

                        const x = cx + Math.cos(ang) * ringR;
                        const y = cy + Math.sin(ang) * ringR;

                        drawGlowDot(x, y, CFG.cyan, 0.92, CFG.packetSize, CFG.packetGlow);

                        if (t > 0.80) {
                            routeHint = p.laneId;
                            hintA = clamp((t - 0.80) / 0.20, 0, 1);
                        }

                        if (t >= 1) {
                            p.state = "holdExit";
                            p.holdStart = now;
                        }
                    }

                    // HOLD at exit (bottom)
                    else if (p.state === "holdExit") {
                        const x = L.rx;
                        const y = L.ry + ringR;

                        drawGlowDot(x, y, CFG.cyan, 0.95, CFG.packetSize, CFG.packetGlow);

                        routeHint = p.laneId;
                        hintA = 1;

                        const holdT = clamp((now - p.holdStart) / CFG.exitHoldMs, 0, 1);
                        if (holdT >= 1) {
                            lanePulseAt[p.laneId] = now;
                            splitFlashUntil = now + CFG.splitFlashMs;
                            lastChosenLane = p.laneId;

                            p.state = "out";
                            p.outStart = now;
                        }
                    }

                    // OUT to destination
                    else if (p.state === "out") {
                        const t = clamp((now - p.outStart) / CFG.outDurMs, 0, 1);
                        const e = easeInOutSine(t);

                        const c = curves.find(z => z.laneId === p.laneId);
                        if (!c) continue;

                        const pos = bezierPoint(c.p0, c.p1, c.p2, c.p3, e);
                        const rgb = laneColor(p.laneId);

                        // trail while routing out only
                        if (t < CFG.tailCutoffT) {
                            for (let k = 0; k < CFG.tailSteps; k++) {
                                const tt = clamp(e - (k * 0.022), 0, 1);
                                const tp = bezierPoint(c.p0, c.p1, c.p2, c.p3, tt);
                                const ta = (1 - k / CFG.tailSteps) * 0.18;
                                drawGlowDot(tp.x, tp.y, rgb, ta, CFG.packetSize * 0.82, CFG.packetGlow * 0.75);
                            }
                        }

                        // main packet
                        drawGlowDot(pos.x, pos.y, rgb, 0.95, CFG.packetSize * 1.12, CFG.packetGlow);

                        // arrived
                        if (t >= 1) {
                            pillFlashAt[p.laneId] = now;
                            lanePulseAt[p.laneId] = now;

                            if (p.isBoot && !firstTrendDone) {
                                firstTrendDone = true;
                                allowRandomSpawns = true;
                                nextSpawnAt = now + rand(1400, 3200);
                            }

                            packets.splice(i, 1);
                        }
                    }
                }

                // forwarder label ABOVE ring
                drawNodeLabel(L.rx, L.ry - (ringR + 34), "FORWARDER BOT", CFG.cyan, 0.95, true);

                // ring last
                drawMagneticRing(L.rx, L.ry, ringR, now, routeHint, hintA);

                // vignette
                ctx.save();
                const vg = ctx.createRadialGradient(
                    W * 0.5, H * 0.5,
                    Math.min(W, H) * 0.22,
                    W * 0.5, H * 0.5,
                    Math.min(W, H) * 0.88
                );
                vg.addColorStop(0.0, "rgba(0,0,0,0)");
                vg.addColorStop(1.0, `rgba(0,0,0,${CFG.vignette})`);
                ctx.fillStyle = vg;
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
            }

            function loop(now) {
                draw(now);
                requestAnimationFrame(loop);
            }

            // Boot
            resize();

            // First packet forced to TREND
            const bootNow = performance.now();
            spawnPacket(bootNow, 1, true);

            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>